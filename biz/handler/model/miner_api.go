// Code generated by hertz generator.

package model

import (
	"context"
	"github.com/bytedance/gopkg/util/logger"
	"github.com/qcq1/common/gptr"
	"github.com/qcq1/common/gslice"
	"github.com/qcq1/common/render"
	"github.com/qcq1/rpc_miner_core/kitex_gen/miner_core"
	"miner_api/biz/common/Status"
	"miner_api/biz/sal/rpc/miner_miner_core"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	model "miner_api/biz/model"
)

// QueryJobList .
// @router /job/query/list [POST]
func QueryJobList(ctx context.Context, c *app.RequestContext) {
	NewQueryJobListHandler(ctx, c).Handle()
}

type QueryJobListHandler struct {
	ctx      context.Context
	hertzCtx *app.RequestContext

	respData *model.QueryJobListData
}

func NewQueryJobListHandler(ctx context.Context, hertzCtx *app.RequestContext) *QueryJobListHandler {
	return &QueryJobListHandler{
		ctx:      ctx,
		hertzCtx: hertzCtx,
	}
}

func (h *QueryJobListHandler) Handle() {
	ctx := h.ctx
	var req model.QueryJobListReq
	err := h.hertzCtx.BindAndValidate(&req)
	if err != nil {
		h.hertzCtx.String(consts.StatusBadRequest, err.Error())
		return
	}

	coreResp, err := miner_miner_core.RawCall.QueryJobList(ctx, h.HttpReq2RpcReq(&req))
	if err != nil {
		logger.CtxErrorf(ctx, "miner_miner_core.RawCall.GetItem failed, err = %v", err)
		return
	}

	h.respData = h.RpcResp2HttpResp(coreResp)
	h.ReturnResp(Status.Success, err)
}

func (h *QueryJobListHandler) ReturnResp(status *Status.Status, err error) {
	if err != nil {
		logger.CtxErrorf(h.ctx, "Hello failed, err = %v", err)
	}
	resp := new(model.QueryJobListResp)
	resp.Code = status.Code()
	resp.Message = status.Message()
	if status.Code() == Status.Success.Code() && err == nil {
		resp.Data = h.respData
	}
	logger.CtxInfof(h.ctx, "Hello, resp = %v", render.Render(resp))
	h.hertzCtx.JSON(consts.StatusOK, &resp)
}

func (h *QueryJobListHandler) HttpReq2RpcReq(httpReq *model.QueryJobListReq) *miner_core.QueryJobListReq {
	return &miner_core.QueryJobListReq{
		PageNum:  httpReq.PageNum,
		PageSize: httpReq.PageSize,
		OrderBy:  (*miner_core.JobColumn)(gptr.Of(int64(gptr.Indirect(httpReq.OrderBy)))),
		Order:    (*miner_core.Order)(gptr.Of(int64(gptr.Indirect(httpReq.Order)))),

		Id:             httpReq.Id,
		CreatedBy:      httpReq.CreatedBy,
		CreatedAtStart: httpReq.CreatedAtStart,
		CreatedAtEnd:   httpReq.CreatedAtEnd,
	}
}

func (h *QueryJobListHandler) RpcResp2HttpResp(rpcResp *miner_core.QueryJobListResp) *model.QueryJobListData {
	return &model.QueryJobListData{
		JobList: gslice.Map(rpcResp.JobList, func(v *miner_core.Job) *model.Job {
			return &model.Job{
				Id:          v.Id,
				Name:        v.Name,
				Description: v.Description,
				CreatedBy:   v.CreatedBy,
				UpdatedBy:   v.UpdatedBy,
				CreatedAt:   v.CreatedAt,
				UpdatedAt:   v.UpdatedAt,
				Extra:       v.Extra,
			}
		}),
		Total: rpcResp.Total,
	}
}
