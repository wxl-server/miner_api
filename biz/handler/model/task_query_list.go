// Code generated by hertz generator.

package model

import (
	"context"
	"miner_api/biz/common/Status"
	"miner_api/biz/sal/rpc/miner_core_rpc"

	model "miner_api/biz/model"

	"github.com/bytedance/gopkg/util/logger"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/wxl-server/common/gptr"
	"github.com/wxl-server/common/gslice"
	"github.com/wxl-server/idl_gen/kitex_gen/miner_core"
)

// QueryTaskList .
// @router /task/query/list [GET]
func QueryTaskList(ctx context.Context, c *app.RequestContext) {
	NewQueryTaskListHandler(ctx, c).Handle()
}

type QueryTaskListHandler struct {
	ctx      context.Context
	hertzCtx *app.RequestContext

	respData *model.QueryTaskListData
}

func NewQueryTaskListHandler(ctx context.Context, hertzCtx *app.RequestContext) *QueryTaskListHandler {
	return &QueryTaskListHandler{
		ctx:      ctx,
		hertzCtx: hertzCtx,
	}
}

func (h *QueryTaskListHandler) Handle() {
	ctx := h.ctx
	var req model.QueryTaskListReq
	err := h.hertzCtx.BindAndValidate(&req)
	if err != nil {
		h.ReturnResp(Status.RequestParamsInvalid, err)
		return
	}

	coreResp, err := miner_core_rpc.QueryTaskList(ctx, h.HttpReq2RpcReq(&req))
	if err != nil {
		logger.CtxErrorf(ctx, "miner_core.RawCall.QueryTaskList failed, err = %v", err)
		h.ReturnResp(Status.InternalError, err)
		return
	}

	h.respData = h.RpcResp2HttpResp(coreResp)
	h.ReturnResp(Status.Success, err)
}

func (h *QueryTaskListHandler) ReturnResp(status *Status.Status, err error) {
	if err != nil {
		logger.CtxErrorf(h.ctx, "QueryTaskList failed, err = %v", err)
	}
	resp := new(model.QueryTaskListResp)
	resp.Code = status.Code()
	resp.Message = status.Message()
	if status.Code() == Status.Success.Code() && err == nil {
		resp.Data = h.respData
	}
	h.hertzCtx.JSON(consts.StatusOK, &resp)
}

func (h *QueryTaskListHandler) HttpReq2RpcReq(httpReq *model.QueryTaskListReq) *miner_core.QueryTaskListReq {
	return &miner_core.QueryTaskListReq{
		PageNum:  gptr.Indirect(httpReq.PageNum),
		PageSize: gptr.Indirect(httpReq.PageSize),

		Id:    httpReq.Id,
		JobId: httpReq.JobId,
	}
}

func (h *QueryTaskListHandler) RpcResp2HttpResp(rpcResp *miner_core.QueryTaskListResp) *model.QueryTaskListData {
	return &model.QueryTaskListData{
		TaskList: gslice.Map(rpcResp.TaskList, func(v *miner_core.Task) *model.Task {
			return &model.Task{
				Id:           gptr.Of(v.Id),
				JobId:        gptr.Of(v.JobId),
				Name:         gptr.Of(v.Name),
				TotalRecords: v.TotalRecords,
				Status:       gptr.Of(model.TaskStatus(v.Status)),
				CreatedBy: &model.User{
					Id:    gptr.Of(v.CreatedBy.Id),
					Email: gptr.Of(v.CreatedBy.Email),
				},
				CreatedAt: gptr.Of(v.CreatedAt),
				TimeCost:  v.TimeCost,
				Rules: gslice.Map(v.Rules, func(rule *miner_core.Rule) *model.Rule {
					return &model.Rule{
						Id:           gptr.Of(rule.Id),
						FactorCode:   gptr.Of(rule.FactorCode),
						OperatorCode: gptr.Of(rule.OperatorCode),
						ValueList:    rule.ValueList,
					}
				}),
				LogicExpression: gptr.Of(v.LogicExpression),
				Limit:           gptr.Of(v.Limit),
				Extra:           v.Extra,
			}
		}),
		Total: gptr.Of(rpcResp.Total),
	}
}

func (h *QueryTaskListHandler) rpcUser2HttpUser(rpcUser *miner_core.User) *model.User {
	return &model.User{
		Id:    gptr.Of(rpcUser.Id),
		Email: gptr.Of(rpcUser.Email),
	}
}
