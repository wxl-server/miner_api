// Code generated by hertz generator.

package model

import (
	"context"
	"miner_api/biz/common/Status"
	"miner_api/biz/sal/rpc/miner_core_rpc"

	model "miner_api/biz/model"

	"github.com/bytedance/gopkg/util/logger"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/wxl-server/common/gptr"
	"github.com/wxl-server/common/gslice"
	"github.com/wxl-server/idl_gen/kitex_gen/miner_core"
)

// QueryIndicatorList .
// @router /indicator/query/list [POST]
func QueryIndicatorList(ctx context.Context, c *app.RequestContext) {
	NewQueryIndicatorListHandler(ctx, c).Handle()
}

type QueryIndicatorListHandler struct {
	ctx      context.Context
	hertzCtx *app.RequestContext

	respData *model.QueryIndicatorListData
}

func NewQueryIndicatorListHandler(ctx context.Context, hertzCtx *app.RequestContext) *QueryIndicatorListHandler {
	return &QueryIndicatorListHandler{
		ctx:      ctx,
		hertzCtx: hertzCtx,
	}
}

func (h *QueryIndicatorListHandler) Handle() {
	ctx := h.ctx
	var req model.QueryIndicatorListReq
	err := h.hertzCtx.BindAndValidate(&req)
	if err != nil {
		h.ReturnResp(Status.RequestParamsInvalid, err)
		return
	}

	resp, err := miner_core_rpc.QueryIndicatorList(ctx, h.HttpReq2RpcReq(&req))
	if err != nil {
		logger.CtxErrorf(ctx, "miner_core_rpc.QueryIndicatorList failed, err = %v", err)
		h.ReturnResp(Status.InternalError, err)
		return
	}

	h.respData = h.RpcResp2HttpResp(resp)
	h.ReturnResp(Status.Success, err)
}

func (h *QueryIndicatorListHandler) HttpReq2RpcReq(httpReq *model.QueryIndicatorListReq) *miner_core.QueryIndicatorListReq {
	return &miner_core.QueryIndicatorListReq{}
}

func (h *QueryIndicatorListHandler) RpcResp2HttpResp(rpcResp *miner_core.QueryIndicatorListResp) *model.QueryIndicatorListData {
	indicators := gslice.Map(rpcResp.Indicators, func(v *miner_core.FirstLevelIndicator) *model.FirstLevelIndicator {
		children := gslice.Map(v.Children, func(v *miner_core.SecondLevelIndicator) *model.SecondLevelIndicator {
			allowOperators := gslice.Map(v.AllowOperators, func(v *miner_core.AllowOperators) *model.AllowOperators {
				allowValues := gslice.Map(v.AllowValues, func(v *miner_core.AllowValues) *model.AllowValues {
					return &model.AllowValues{
						DisplayName: gptr.Of(v.DisplayName),
						Value:       gptr.Of(v.Value),
					}
				})
				return &model.AllowOperators{
					OperatorCode: gptr.Of(v.OperatorCode),
					DisplayName:  gptr.Of(v.DisplayName),
					InputElType:  gptr.Of(model.InputElType(v.InputElType)),
					AllowValues:  allowValues,
				}
			})
			return &model.SecondLevelIndicator{
				FactorCode:     gptr.Of(v.FactorCode),
				DisplayName:    gptr.Of(v.DisplayName),
				AllowOperators: allowOperators,
			}
		})
		return &model.FirstLevelIndicator{
			DisplayName: gptr.Of(v.DisplayName),
			Children:    children,
		}
	})
	return &model.QueryIndicatorListData{
		Indicators: indicators,
	}
}

func (h *QueryIndicatorListHandler) ReturnResp(status *Status.Status, err error) {
	if err != nil {
		logger.CtxErrorf(h.ctx, "QueryIndicatorList failed, err = %v", err)
	}
	resp := new(model.QueryIndicatorListResp)
	resp.Code = status.Code()
	resp.Message = status.Message()
	if status.Code() == Status.Success.Code() && err == nil {
		resp.Data = h.respData
	}
	h.hertzCtx.JSON(consts.StatusOK, &resp)
}
